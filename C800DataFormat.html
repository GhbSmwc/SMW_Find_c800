<h1>SMW's Level block format</h1>
In SMW's levels, RAM address $C800 in banks $7E/$7F ($40/$41 in SA-1) contains all the block data of layer 1 and 2 (if the level is a layer 2 level). They hold the map 16 number/ID
for every tile in the current level with the low bytes in bank $7E ($40 SA-1) and high bytes in bank $7F ($41 SA-1). The format of the blocks as follows:
<h2>Horizontal levels</h2>
<ol>
<li>Within each screen column, each subsequent byte in memory starting at $C800 is the next block in level from left to right and then next row from left to right again (row-major):<br>
<img src="Readme_files/SMW_RowMajorBlocksPerScreen.png"></li>
<li>Once the <b>bottom</b> of the level is reached, the next screen column starting from the top-left and repeats the pattern. Note that this continues down the screen columns even if there
are multiple rows of screen boundaries and not the next &ldquo;screen number&rdquo; displayed in Lunar Magic:<br>
<img src="Readme_files/SMW_ColumnMajorScreenColumn.png"></li>
</ol>
<h3>Calculating the coordinates and reverse.</h3>
<img src="Readme_files/ComputationHorizLevel.png">
<ol>
<li>Formula to calculate to find the index is <kbd>Index = (BlocksPerScrnCol * floor(XPos/16)) + (YPos*16) + (XPos MOD 16)</kbd>.</li>
<li>Formula to calculate to find the coordinates is:
<ul>
<li><kbd>XPos = (floor(BlockIndex/BlocksPerScreenCol)*16) + (Index MOD 16)</kbd></li>
<li><kbd>YPos = floor((BlockIndex MOD BlocksPerScreenCol)/16)</kbd></li>
</ul>

<kbd>BlocksPerScreenCol</kbd> Is simply RAM address $13D7. This not only contains the level height in pixels, it is also the number of blocks
per screen column.
</li>
</ol>
<h2>Vertical levels</h2>
<ol>
<li>Similar to horizontal levels, but does the row-major format within each half (or every subscreen boundary) of the screen:<br>
<img src="Readme_files/SMW_VerticalLevelFormat.png"></li>
<li>Once the last block of the screen boundary is reached, it repeats the whole process on the next screen.<br>
<img src="Readme_files/SMW_VerticalLevelFormatByScreen.png"></li>
</ol>
<h3>Calculating the coordinates and reverse.</h3>
<img src="Readme_files/ComputationVertLevel.png">
<ol>
<li>Similar to horizontal levels, but because there are no dimension settings for vertical levels, the task is much easier, and even more so thanks
to the fact that each screen's width and height and the number of blocks are all powers of 2, making easy use of bitwise operations. In fact, the index
in binary is <kbd>%00YYYYYXyyyyxxxx</kbd>, where uppercase X and Y represents what screen boundary and what halves (X = 0 for left and 1 for right)
within a screen boundary.</li>
</ol>
<ul>
<li>Formula to calculate to find the index is <kbd>Index = (512 * floor(YPos/16)) + (256 * floor(XPos/16)) + ((YPos MOD 16)*16) + (XPos MOD 16)</kbd></li>
<li>To get the coordinates:
<ul>
<li><kbd>XPos = (floor((BlockIndex MOD 512)/256)*16) + (BlockIndex MOD 16)</kbd></li>
<li><kbd>YPos = (floor(BlockIndex/512)*16) + (floor(BlockIndex/16) MOD 16)</kbd></li>
</ul>
</li>
</ul>
<h2>Other information</h2>
<ul>
<li>When using Layer 2 (or layer 3) levels, the width of the level in horizontal levels or the height in vertical levels is halved, rounded downwards to
the nearest screen boundary. The other &ldquo;half&rdquo; (in quotes because it is not always exactly) of the $C800 table is used up by layer 2/3 in the
same data format order pattern as layer 1.</li>
<li>If there is an odd number of H-screens, such as &ldquo;<kbd>$06: Height=$026 tiles, MaxHScreens=$17</kbd>&rdquo; on a layer 2 horizontal level, there
is a gap between the last byte of layer 1 and the first byte of layer 2 of a size equal to the number of blocks per screen column. For example of the mentioned setting:<br>
<img src="Readme_files/GapBetweenLayer1And2.png"><br>
I placed the blocks in an increasing map16 order, with layer 1 blocks on the bottom of the last screen and layer 2 on the first screen on the top so you can see
it easier when viewed on a debugger. Looking at memory editor we can see there is an unused gap:<br>
<img src="Readme_files/GapBetweenLayer1And2Dbg.png"><br>
Notice the gap ranging from $7EE220 to $7EE47F (this also applies to its next bank, $7F (or $41 in SA-1)). This gap is 608 ($260 in hex) bytes long, this is also
the number of blocks per screen column (16*38 = 608). This gap being the number of blocks per screen column bytes long always works when having any odd-number
of H-screens for a layer 2 level. It's unknown why <a href="https://www.smwcentral.net/?p=profile&id=8251">Vitor Vilela</a>/<a href="https://www.smwcentral.net/?p=profile&id=9435">FuSoYa</a>
they decided to position the layer 2 table in such a position, probably due to the rounding of the number of screens downwards to an integer as odd numbers isn't
divisible by 2.</li>
</ul>