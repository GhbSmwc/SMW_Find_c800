<html>
	<head>
		<style>
			html {
			background-color: #101010;
			color: rgb(221, 221, 221);
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
			
			abbr{cursor: help;}
			img.img-hor {
				-moz-transform: scaleX(-1);
				-o-transform: scaleX(-1);
				-webkit-transform: scaleX(-1);
				transform: scaleX(-1);
				filter: FlipH;
				-ms-filter: "FlipH";
			}
			
			input[type=text], input[type=number], td.Statistics, text {
				font-family: monospace;
			}
			
			td.Monospace {
				font-family: monospace;
			}
			div.Indent {
				padding-left: 20px;
			}
			.MathFormula {
				font-family: monospace;
				white-space: pre;
			}
			div.CodeBlock {
				border: 1px solid white;
				overflow: auto;
				width: 800px;
				height: 300px;
				resize: both;
			}
			pre {
				margin: 0px;
			}
		</style>
	</head>
<body style="max-width: 720px; margin: auto; padding: 15px">
<p>See <a href="JS_C800Calculator.html">JS_C800Calculator.html</a> to obtain values of which block in the level along with statistics</p>
<div>
	<b>Table of contents</b>
	<ol>
		<li id="TOCBack_Introduction"><a href="#TOC_Introduction">Introduction</a></li>
		<li><a id="TOCBack_Horizontal_level_block_format" href="#TOC_Horizontal_level_block_format">Horizontal level block format</a>
			<ol>
				<li><a id="TOCBack_CalculateHorizLevels" href="#TOC_CalculateHorizLevels">Calculating Index &lt;-&gt; Coordinates of horizontal levels</a></li>
			</ol>
		</li>
		<li><a id="TOCBack_Vertical_level_block_format" href="#TOC_Vertical_level_block_format">Vertical level block format</a>
			<ol>
				<li><a id="TOCBack_CalculateVertLevels" href="#TOC_CalculateVertLevels">Calculating Index &lt;-&gt; Coordinates of vertical levels</a></li>
			</ol>
		</li>
		<li><a id="TOCBack_OtherInfo" href="#TOC_OtherInfo">Other information</a></li>
	</ol>
</div>
<h1><a id="TOC_Introduction" href="#TOCBack_Introduction">^</a>Introduction</h1>
<p>In SMW, during levels, save for boss levels, is loaded, the tile data, which keeps track of every tile on how Mario and sprites interact with blocks on layer 1 (or layer 2), are stored in RAM <a href="https://smwc.me/m/smw/ram/7EC800"><kbd>$7EC800</kbd></a> for low byte map16 numbers and <a href="https://smwc.me/m/smw/ram/7FC800"><kbd>$7FC800</kbd></a> for the high bytes.</p>

<p>In a SA-1 game, it would be at address <kbd>$40C800</kbd> and <kbd>$41C800</kbd> instead.</p>

<p>Because the 2 lower bytes (low word, or &ldquo;page&rdquo;) of the 24-bit (3-bit) address are the same on different banks (leftmost byte of the 3-byte), I'll be referring the blocks by their page.</p>

<p>When a block is in a level, its map16 number, which each being 2 bytes long, are written on both banks on the same page, with the low byte on the lower bank value ($7E/$40) and the high byte in the higher bank value ($7F/$41). For example a cement block, which is tile <kbd>$<span style="color: #ff0000">01</span><span style="color: #0000ff">30</span></kbd>, placed at the top-left of the level, which is <kbd>X: $0000, Y: $0000</kbd> in block units (not pixels),
would mean <kbd>$7E/40:C800: $<span style="color: #0000ff">30</span></kbd> and <kbd>$7F/41:C800: $<span style="color: #ff0000">01</span></kbd>. Each byte on both banks correspond to a block, using the same example but at <kbd>X: $0001, Y: $0000</kbd> would cause the cement block to to be written to <kbd>$C801</kbd> of both banks instead. Here is what it looks like:
<table>
	<tr>
		<th></th>
		<th>+0</th>
		<th>+1</th>
		<th>+2</th>
		<th>+3</th>
		<th>...</th>
	</tr>
	<tr>
		<th>In banks $7E/$40</th>
		<td class="Monospace">$C800 (X:$0000,Y:$0000)</td>
		<td class="Monospace">$C801 (X:$0001,Y:$0000)</td>
		<td class="Monospace">$C802 (X:$0002,Y:$0000)</td>
		<td class="Monospace">$C803 (X:$0003,Y:$0000)</td>
		<td>...</td>
	</tr>
	<tr>
		<th>In banks $7F/$41</th>
		<td class="Monospace">$C800 (X:$0000,Y:$0000)</td>
		<td class="Monospace">$C801 (X:$0001,Y:$0000)</td>
		<td class="Monospace">$C802 (X:$0002,Y:$0000)</td>
		<td class="Monospace">$C803 (X:$0003,Y:$0000)</td>
		<td>...</td>
	</tr>
</table>
</p>

<p>Now you may be wondering, how are the blocks being placed in a two-dimensional array when their data is stored in a linear array? Well, SMW, and by extension, Lunar Magic utilizes a combination of
<a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">row and column-major</a> <a href="https://en.wikipedia.org/wiki/Array_(data_type)#Multi-dimensional_arrays">multidimensional array</a>. The format stored in the RAM
differs depending on horizontal level and vertical level. Since LM added custom horizontal level dimensions, that also differs the layout of the blocks (primarily due to the blocks per screen column).</p>
<p>Notes:
	<ul>
		<li>
			Coordinates discussed here are in units of blocks, not pixels. To convert pixel coordinates to block coordinates, do <span class="MathFormula">BlockXPos = floor(PixelXPos/16)</span> and <span class="MathFormula">BlockYPos = floor(PixelYPos/16)</span>. <a href="https://en.wikipedia.org/wiki/Floor_and_ceiling_functions"><kbd>floor()</kbd></a> is a function
			that rounds down a number; picking the highest integer less-than or equal to the input. In ASM programming, division by 16 and rounding down can be performed via <span class="MathFormula">LSR #4</span> (shift bits to the right by 4 bits).
			<ul>
				<li>As a side note, RAM <kbd>$98~$99</kbd> (Y position) and <kbd>$9A~$9B</kbd> (X position) are entity collision point positions <b>in pixels</b>, as they are used to handle collision points currently processed by Mario and
				Sprite to see if a given pixel coordinate is within which block in a 16x16 block grid. Various routines such as &ldquo;ChangeMap16&rdquo; or &ldquo;GetMap16&rdquo;, using <kbd>$98~$9B</kbd> however, rounds these values to the nearest
				multiple of 16 (done via <kbd>AND #$FFF0</kbd>) internally.</li>
			</ul>
		</li>
		<li>As always, X increases going rightwards, and Y increases going downwards. 2D Computer graphics often have the Y-axis orientated downwards, the same way how we read English text. Here is what it looks like:<br>
		<img src="Readme_files/BlockCoordinateSystem.png"></li>
		<li>Lunar Magic displays the block coordinate in the level on the status bar on the bottom-left corner of the window when hovering a mouse within the level boundaries:<br>
			<img src="Readme_files/LM_BlockCoordDisplay.png"><br>
			Note that before version 3.03 (released in April 1, 2019), the coordinates are displayed in <b>decimal</b> rather than hex.
		</li>
		<li>On layer 2 levels, layer 2 will have the same arrangement of blocks format as layer 1 for both horizontal and vertical levels. It will, however be reserving second half (roughly if there's an odd number of screens wide) of the <kbd>$C800</kbd> table memory.</li>
	</ul>
</p>
<h1><a id="TOC_Horizontal_level_block_format" href="#TOCBack_Horizontal_level_block_format">^</a>Horizontal level block format</h1>
<div class="Indent">
	<p>In horizontal levels, the grid of blocks are divided by 16-block wide &ldquo;screen columns&rdquo;, then subdivided those screen columns into many rows of 16x1 block groups.</p>
	<p>Let's start with the smallest unit of chunking first, the blocks are ordered like a newspaper text:
	<img src="Readme_files/SMW_RowMajorBlocksPerScreen.png">
	</p>
	
	<p>Now, I used the term &ldquo;screen columns&rdquo; for a reason. When enumerating past the last block within the screen exit boundary (the blue-bordered chunks seen in Lunar Magic when &ldquo;View Screen Exits&rdquo; is turned on),
	you advance to the top-leftmost block of a screen exit <b>below</b>, rather than the screen exit <b>to the right</b> (unlike the screen exit numbering). If the bottom of the level is reached, however, then it would be the top screen exit to the right, for example:
	<img src="Readme_files/SMW_ColumnMajorScreenColumn.png"><br>
	Starting from screen $00, blocks are enumerated left to right, and going past the rightmost block in the screen column, the next block would be the leftmost block but now down a row, and repeats. When the bottom row's last block in a screen exit boundary is reached (shown in red),
	the next block would be the top-leftmost block the screen below (in orange). Finally, when reaching the bottom of the level, after the last block in the screen column (yellow), the next block would be the first block of the next column (green).
	</p>
	<div class="Indent">
		<h2><a id="TOC_CalculateHorizLevels" href="#TOCBack_CalculateHorizLevels">^</a>Calculating Index &lt;-&gt; Coordinates of horizontal levels</h2>
		<p>Because the block grid is subdivided this way, here's a visual on how I solved a formula on converting the index and coordinates:
		<img src="Readme_files/ComputationHorizLevel.png">
		</p>
		<p>Formula in text form:
			<ul>
				<li>Obtain Index: <span class="MathFormula">Index = (BlocksPerScrnCol * floor(XPos/16)) + (YPos*16) + (XPos MOD 16)</span></li>
				<li>Obtain X and Y positions (<a href="https://en.wikipedia.org/wiki/Euclidean_division">euclidean division</a> frequently used here):
					<ul>
						<li class="MathFormula">XPos = (floor(BlockIndex/BlocksPerScreenColumn)*16) + (Index MOD 16)</li>
						<li class="MathFormula">YPos = floor((BlockIndex MOD BlocksPerScreenColumn)/16)</li>
					</ul>
				</li>
			</ul>
			Notes:
			<ul>
				<li>
					RAM <kbd><a href="https://smwc.me/m/smw/ram/7E13D7">$13D7 ($73D7 in SA-1)</a></kbd> is the level height in pixels, but because every screen column in horizontal levels are always 16 blocks wide, and that blocks are always 16 pixels high,
					this is also the number of blocks per screen column (we do this: <span class="MathFormula">LevelHeightInBlocks = LevelHeightInPixels / 16 pixels per block</span> &rarr; <span class="MathFormula">BlocksPerScreenColumn = LevelHeightInBlocks * 16 across each screen</span>, resulting in dividing by 16, then multiplying back up by 16).
				</li>
				<li>
					<kbd>Mod</kbd> is the modulo operator, the remainder of dividing two numbers. For example: <span class="MathFormula">18/16</span>, in <a href="https://en.wikipedia.org/wiki/Euclidean_division">Euclidean Division</a>, is <span class="MathFormula">quotient = 1, remainder = 2</span>. therefore
					<span class="MathFormula">18 MOD 16</span> will output <kbd>2</kbd>.
				</li>
			</ul>
		</p>
	</div>
</div>
<h1><a id="TOC_Vertical_level_block_format" href="#TOCBack_Vertical_level_block_format">^</a>Vertical level block format</h1>
<div class="Indent">
	<p>Vertical levels are formatted like this: The grid is divided into 32x16-block screen exits, then they are subdivided by the 2 16x16 sub-screen areas (left and right half of the screen exit), and finally subdivided again by 16x1 areas:
	<img src="Readme_files/SMW_VerticalLevelFormat.png">
	</p>
	<p>When enumerating past the last block in a screen exit, it repeats on the next screen exit down:
	<img src="Readme_files/SMW_VerticalLevelFormatByScreen.png">
	</p>
	<h2><a id="TOC_CalculateVertLevels" href="#TOCBack_CalculateVertLevels">^</a>Calculating Index &lt;-&gt; Coordinates of vertical levels</h2>
	<div class="Indent">
		<img src="Readme_files/ComputationVertLevel.png">
	
		<p>Similar to horizontal levels, but because there are no dimension settings for vertical levels, the task is much easier, and even more so thanks to the fact that each screen's width and height and the number of blocks are all powers of 2, making easy use of bitwise operations (just re-arrange the sequence of bits).
		In fact, the index in binary is <kbd>%00YYYYYXyyyyxxxx</kbd>, where uppercase X and Y represents what screen boundary and what halves (X = 0 for left and 1 for right) within a screen boundary.</p>
		<p>Formulas:
		<ul>
			<li>To calculate index: <span class="MathFormula">Index = (512 * floor(YPos/16)) + (256 * floor(XPos/16)) + ((YPos MOD 16)*16) + (XPos MOD 16)</span></li>
			<li>To calculate coordinates:
				<ul>
					<li class="MathFormula">XPos = (floor((BlockIndex MOD 512)/256)*16) + (BlockIndex MOD 16)</li>
					<li class="MathFormula">YPos = (floor(BlockIndex/512)*16) + (floor(BlockIndex/16) MOD 16)</li>
				</ul>
			</li>
		</ul>
		</p>
	</div>
</div>
<h1><a id="TOC_OtherInfo" href="#TOCBack_OtherInfo">^</a>Other information</h1>
<div class="Indent">
	<ul>
	<li><p>When using Layer 2 (or layer 3) levels, the width of the level in horizontal levels or the height in vertical levels is halved, rounded downwards to
	the nearest screen boundary. The other &ldquo;half&rdquo; (in quotes because it is not always exactly) of the $C800 table is used up by layer 2/3 in the
	same data format order pattern as layer 1.</p></li>
	
	<li>For layer 2 levels, to get the corresponding position of something relative to layer 1 but on layer 2 that may be moved around, you would do this:
	<span class="MathFormula">ConvertedLayer2XY = PositionRelativeToLevelXY + (Layer2XYScreen - Layer1XYScreen)</span>, then perform interaction with layer 2 using <kbd>ConvertedLayer2XY</kbd> instead of
	<kbd>PositionRelativeToLevelXY</kbd> (and make sure RAM <a href="https://www.smwcentral.net/?p=memorymap&game=smw&u=0&address=1933&sizeOperation=%3D&sizeValue=&region[]=ram&type=*&description="><kbd>$1933</kbd></a> is set to <kbd>#$01</kbd> so subroutines you use also goes layer 2 mode),
	and then reverse the offset when you are done: <span class="MathFormula">RestoredXYPos = ConvertedLayer2XY - (Layer2XYScreen - Layer1XYScreen)</span>. In SMW, a code
	at <kbd>$00E953</kbd> does this:
<div class="CodeBlock"><pre>
CODE_00E94C:        A9 01         LDA.B #$01                ;\ process layer 2
CODE_00E94E:        8D 33 19      STA.W $1933               ;/
CODE_00E951:        C2 20         REP #$20                  ; Accum (16 bit) 
CODE_00E953:        A5 94         LDA RAM_MarioXPos         ;\Temporally displace mario's position, this makes it so that layer 2 interaction account for layer 2 being moved.
CODE_00E955:        18            CLC                       ;|
CODE_00E956:        65 26         ADC $26                   ;|Mario's position is now ConvertedLayer2XY.
CODE_00E958:        85 94         STA RAM_MarioXPos         ;|
CODE_00E95A:        A5 96         LDA RAM_MarioYPos         ;|
CODE_00E95C:        18            CLC                       ;|
CODE_00E95D:        65 28         ADC $28                   ;|
CODE_00E95F:        85 96         STA RAM_MarioYPos         ;/
CODE_00E961:        E2 20         SEP #$20                  ; Accum (8 bit) 
CODE_00E963:        20 DB EA      JSR.W CODE_00EADB         
CODE_00E966:        C2 20         REP #$20                  ; Accum (16 bit) 
CODE_00E968:        A5 94         LDA RAM_MarioXPos         ;\reverse the displacement of mairo's position to counteract the above code. NOTE that this doesn't use push-pull stack
CODE_00E96A:        38            SEC                       ;|so that blocks that sets player XY position aren't canceled (pull commands (PLA/PLX/PLY) followed by "store" (STA/STX/STY)
CODE_00E96B:        E5 26         SBC $26                   ;|would always set them to specific value no matter of the changes before it by blocks)
CODE_00E96D:        85 94         STA RAM_MarioXPos         ;|
CODE_00E96F:        A5 96         LDA RAM_MarioYPos         ;|Mario's Position is now RestoredXYPos.
CODE_00E971:        38            SEC                       ;|
CODE_00E972:        E5 28         SBC $28                   ;|
CODE_00E974:        85 96         STA RAM_MarioYPos         ;/
CODE_00E976:        E2 20         SEP #$20                  ; Accum (8 bit) 
</pre></div>
	RAM <a href="https://www.smwcentral.net/?p=memorymap&game=smw&u=0&address=26-29&sizeOperation=%3D&sizeValue=&region[]=ram&type=*&description="><kbd>$26~$27</kbd> and <kbd>$28~29</kbd></a> contains <span class="MathFormula">(Layer2XYScreen - Layer1XYScreen)</span> which is essentially layer 2's X position relative to layer 1.


	</li>
	<li><p>If there is an odd number of H-screens, such as &ldquo;<kbd>$06: Height=$026 tiles, MaxHScreens=$17</kbd>&rdquo; on a layer 2 horizontal level, there
	is a gap in the data between the last byte of layer 1 and the first byte of layer 2 of a size equal to the number of blocks per screen column. For example of the mentioned setting:<br>
	<img src="Readme_files/GapBetweenLayer1And2.png"><br>
	I placed the blocks in an increasing map16 number order, with layer 1 blocks on the bottom of the last screen and layer 2 on the top of the first screen so you can see
	it easier when viewed on a debugger. Looking at memory editor we can see there is an unused gap:<br>
	<img src="Readme_files/GapBetweenLayer1And2Dbg.png"><br>
	Notice the gap ranging from <kbd>$7EE220</kbd> to <kbd>$7EE47F</kbd> (this also applies to the other bank, as their data position corresponds). This gap is 608 ($260 in hex) bytes long, this is also
	the number of blocks per screen column (16*38 = 608). This gap being the number of blocks per screen column bytes long always exists when having any odd-number
	of H-screens for a layer 2 level, except the 1-screen wide area (setting $1C), which you shouldn't probably use (0-screen wide area = black void).
	It's unknown why <a href="https://www.smwcentral.net/?p=profile&id=8251">Vitor Vilela</a>/<a href="https://www.smwcentral.net/?p=profile&id=9435">FuSoYa</a>
	to position the layer 2 data table in such a position, probably due to the rounding of the number of screens downwards to an integer as odd numbers isn't
	divisible by 2, and also to avoid risking data overlaps of layer 1 and 2.</p></li>
	<li><p>If you write to the <kbd>$C800</kbd> table, it <b>does</b> change the map16 number like you would with GPS's <kbd>change_map16</kbd> routine, however, the graphics will not be updated until
	it is refreshed by level loading (during the screen fades to the level) or when re-entering the player's screen after being scrolled offscreen far enough. This is to prevent
	V-blank overflow by updating the graphics only when necessary at the moment the block is changed during a map16 change routine (instead of writing to V-RAM's
	tilemap and checking every block every frame). You can avoid this graphical glitch by:
	<ul>
	<li>Changing the blocks during UberasmTool's level <kbd>load:</kbd> feature. Note: This executes at the time after the level is cleared (writing all tiles $0025 via
	<kbd>$0582C8</kbd> and <kbd>$05833A</kbd>) and before any LM-placed blocks (all objects and direct map16 tiles), therefore avoid placing any tiles using LM on the spot
	you are going to write your block using uberasm tool's <kbd>load:</kbd>.</li>
	<li>Changing the blocks that are offscreen, beyond the &ldquo;loading seam&rdquo; (a column or row of blocks at the edge of the screen that loads the appropriate graphics to the tilemap).</li>
	<li>Have the block it is changing from and to use the exact same graphic, so the graphics are unnoticeable. Rarely ever you would need this, purposes like if sprites are &ldquo;pseudo-solid&rdquo; by writing
	the blocks they lie on a solid invisible tile instead of using a routine that message boxes, red ? light switch, and invisible solid sprite block (sprite <kbd>#$6D</kbd>) uses, that prevents the player from going through
	the sprite.</li>
	</ul></p></li>
	<li>
		<p>The rightmost boundary for horizontal levels and the bottommost boundary for vertical levels the routines uses to determine if the given coordinate is beyond that boundary is NOT always
		the rightmost/bottommost edge that LM would allow placing stuff there, rather RAM address <a href="https://www.smwcentral.net/?p=memorymap&game=smw&u=0&address=%245E-%245F&sizeOperation=%3D&sizeValue=&region[]=ram&type=*&description="><kbd>$5E</kbd> (horizontal levels) and <kbd>$5F</kbd> (vertical level)</a>.</p>
		
		<p><kbd>$5E</kbd> and <kbd>$5F</kbd> specify the width and height of the level in number of screens (and where the game screen stops scrolling rightwards or downwards), minus 1. This boundary
		can be a lower number than the full width and height of the level.</p>
		
		<p>For example: A horizontal level with a setting of <kbd>$04: Height=$022 tiles, MaxHScreens=$1A</kbd> with $5E set to $02 (therefore, screens 0 and 1 are accessible in-game), if you give a coordinate
		that is beyond screen column 1 (the position the screen stops scrolling rightwards), and then call subroutines involving block coordinates and indexing in <kbd>C800ASMCodes.asm</kbd>, this would flag this as &ldquo;out of bounds&rdquo;, despite being block X position is at or lower than $19F
		(the rightmost X position possible to be placed in the level in LM).</p>
		
		<p>Therefore, this &ldquo;out of bounds&rdquo; detection for the rightmost or bottomost uses the border where the screen scroll ends
		at, not where the level's full dimension ends at. This is set by LM's &ldquo;Number of Screens&rdquo; in &ldquo;Change Properties in Header&rdquo; dialog (don't forget to uncheck the
		&ldquo;Auto-Set Number of Screens&rdquo; in the &ldquo;General Options&rdquo; if you need to change that). The $C800 calculator JavaScript HTML file will always assume the full width and height on determining what RAM is used or not.</p>
	</li>
	
	<li><p>Thankfully, during block interaction (including during custom block code), <kbd>$98</kbd>-<kbd>$9B</kbd> (scratch RAM <kbd>$0A</kbd>-<kbd>$0D</kbd> for sprites after executing <kbd>$019138</kbd>) while processing layer 2 (RAM <a href="https://smwc.me/m/smw/ram/7E1933"><kbd>$1933</kbd></a> set to <kbd>#$01</kbd>),
	their XY positions are relative to the top-left of layer 2, not the level, so this means that if you touch the top-left block on layer 2, regardless of the layer 2 positioning ((<kbd>$1E</kbd> or
	<kbd>$1466</kbd>), (<kbd>$20</kbd> or <kbd>$1468</kbd>)), collision point will read as (<kbd>$000*</kbd>, <kbd>$000*</kbd>). This means you first check <kbd>$1933</kbd>, simply take the coordinates (if in pixels, divide by 16; <kbd>LSR #4</kbd>) as if
	they're layer 1, use the routine to convert to <kbd>$C800</kbd> indexing, and then load where the byte starts for layer 2. The list of layer 2 address follows:
	<ul>
	<li>Setting <kbd>$00</kbd>: <kbd>$E300</kbd></li>
	<li>Setting <kbd>$01</kbd>: <kbd>$E400</kbd></li>
	<li>Setting <kbd>$02</kbd>: <kbd>$E330</kbd></li>
	<li>Setting <kbd>$03</kbd>: <kbd>$E400</kbd></li>
	<li>Setting <kbd>$04</kbd>: <kbd>$E3A0</kbd></li>
	<li>Setting <kbd>$05</kbd>: <kbd>$E3C0</kbd></li>
	<li>Setting <kbd>$06</kbd>: <kbd>$E480</kbd></li>
	<li>Setting <kbd>$07</kbd>: <kbd>$E380</kbd></li>
	<li>Setting <kbd>$08</kbd>: <kbd>$E4E0</kbd></li>
	<li>Setting <kbd>$09</kbd>: <kbd>$E380</kbd></li>
	<li>Setting <kbd>$0A</kbd>: <kbd>$E560</kbd></li>
	<li>Setting <kbd>$0B</kbd>: <kbd>$E390</kbd></li>
	<li>Setting <kbd>$0C</kbd>: <kbd>$E540</kbd></li>
	<li>Setting <kbd>$0D</kbd>: <kbd>$E400</kbd></li>
	<li>Setting <kbd>$0E</kbd>: <kbd>$E580</kbd></li>
	<li>Setting <kbd>$0F</kbd>: <kbd>$E400</kbd></li>
	<li>Setting <kbd>$10</kbd>: <kbd>$E5C0</kbd></li>
	<li>Setting <kbd>$11</kbd>: <kbd>$E3C0</kbd></li>
	<li>Setting <kbd>$12</kbd>: <kbd>$E660</kbd></li>
	<li>Setting <kbd>$13</kbd>: <kbd>$E3D0</kbd></li>
	<li>Setting <kbd>$14</kbd>: <kbd>$E6F0</kbd></li>
	<li>Setting <kbd>$15</kbd>: <kbd>$E400</kbd></li>
	<li>Setting <kbd>$16</kbd>: <kbd>$E800</kbd></li>
	<li>Setting <kbd>$17</kbd>: <kbd>$E3F0</kbd></li>
	<li>Setting <kbd>$18</kbd>: <kbd>$E990</kbd></li>
	<li>Setting <kbd>$19</kbd>: <kbd>$E400</kbd></li>
	<li>Setting <kbd>$1A</kbd>: <kbd>$ED40</kbd></li>
	<li>Setting <kbd>$1B</kbd>: <kbd>$E400</kbd></li>
	</ul></p></li>
	</ul>
</div>