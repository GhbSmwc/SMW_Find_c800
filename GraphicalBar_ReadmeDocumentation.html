<html>
	<head>
		<style>
			html {
			background-color: #000207;
			color: white;
			font-family: sans-serif;
			}
			
			table, th, td {
			border: 1px solid white;
			border-collapse: collapse;
			}
			
			span.NoLineBreak {
				white-space: nowrap;
			}
		</style>
	</head>
<body>
<center><h1>Graphical Bar ELITE</h1><br>
By <a href="https://www.smwcentral.net/?p=profile&id=18802">GreenHammerBro</a><br>
See <a href="https://github.com/GhbSmwc/SMW-Graphical-bar-display">github</a>.</center>
<hr>
<h2>Introduction</h2>
This is a guide on how to setup a display of a value of something as a graphical bar that you see in many games. Unlike some hacks like SMWCP2 and
brutal Mario (both as health bars), which are 1-unit (or piece) per tile being displayed, this package contains code to display multiple units per tile
(8 units normally), as well as representing a ratio of something with any number (1-65535) as the max. This means that this can have more accurate
representation of a value (say it approximate to the nearest pixel instead of 8x8 tile) as a percentage.<br><br>

The purpose of the code contained here is to represent something as a graphical bar to be used on various things like health, progress, percentage of
something, etc. as opposed to merely displaying digits.<br><br>
<h2>Notes</h2>
<ul>
<li>This HTML uses <a href="https://en.wikipedia.org/wiki/ASCII_art">ASCII art</a> to represent something, so make sure you have your browser setting for <a href="https://en.wikipedia.org/wiki/Monospaced_font">fixed-width font</a> such as
&ldquo;Consolas&rdquo; so it displays properly.</li>
<li>You must have at least some ASM knowledge. See this ASM tutorial <a href="https://www.smwcentral.net/?p=section&a=details&id=14268">here.</a></li>
<li>Routines presented here assumes you are using uberasm tool and does not expect you to use on other things like sprites, so routine calls that are outside the routine files are
named <span class="NoLineBreak"><kbd>&lt;ASMFilename&gt;_&lt;RoutineName&gt;</kbd></span> as opposed to just <span class="NoLineBreak"><kbd>&lt;RoutineName&gt;</kbd></span>.</li>
</ul>

<hr>
<h2>The resources you need</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=18113">Uberasm tool</a>, needed for codes to run every frame.</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=18716">Lunar Magic</a>, for level testing purposes.</li>
</ul><br>

<h3>Recommended resources</h3>
<ul>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=16031">Super Status Bar patch</a>, SMW's status bar (or, heads-up display (HUD)) space is really small.</li>
<li><a href="https://www.smwcentral.net/?p=section&a=details&id=15222">Overworld Border plus</a>, required if you want to display a graphical bar on the overworld border
(i.e <kbd>ExampleUsage/Gamemode0E_OWBorderTest.asm</kbd>)</li>
</ul>
<h2>Javascript tools</h2>
<ul><li><a name="TopJSLink" href="readme_files/JS_GraphicalBarCalculator.html">Link to javascript memory usage calculator</a>.</li></ul>
<hr>
<h2>Installation (test run)</h2>
<ol>
<li>First make any necessary changes to the defines in <kbd>GraphicalBarDefines</kbd>. Assuming you testing this out on a clean ROM with nothing
else besides LM making modifications, it is likely you don't have to edit anything. However, if you're planning to use the Super Status Bar patch, open
<kbd>StatusBarSettings.asm</kbd> and change <span class="NoLineBreak"><kbd>!StatusBarFormat</kbd></span> to <kbd>$02</kbd> and <span class="NoLineBreak"><kbd>!StatusBar_UsingCustomProperties</kbd></span>
to <kbd>1</kbd> so that it displays properly.<br><br>
<ul>
<li>Don't forget, if you want to display a graphical bar on the overworld, you need to install the Overworld Border Plus patch (using the vanilla OWB is very difficult
to modify, and that codes here only supports the OWB+ patch). Remember that this have the same tile data format as the super status bar patch, don't worry about
<kbd>!StatusBarFormat</kbd> (this only influences the status bar-related code and not the border) as the routines support hybrid tile formats (you can have status
bar's &ldquo;each next tile is next byte&rdquo; format and OWB+'s &ldquo;each next tile is next 2 bytes over, provided you have set <kbd>!OWPlusAndSSBSameFormat</kbd> to <kbd>0</kbd>).</li><br>

<li>Another thing to note is the define <kbd>!StatusBar_UsingCustomProperties</kbd>, this applies to <b>both</b> the status bar and the overworld border plus patch. This is because both
writes to the status bar and the border reuses the same &ldquo;write tile&rdquo; routine to save space. Thankfully, most status bar patches that are layer 3-based,
regardless of the formats, will likely enable you to edit their tile properties, so its more likely you have to set this define to 1 (its 0 by default).</li><br>
</ul>

</li>
<li>Now paste the folders:
<ul>
<li><kbd>GraphicalBarDefines</kbd> (the folder itself) &rightarrow; Uberasm tool's main directory (same area as the .exe)</li>
<li><kbd>GraphicalBarELITE.asm</kbd> &rightarrow; Uberasm tool's <kbd>library</kbd>.</li>
<li><b>Inside</b> the folder <kbd>ExampleUsage</kbd>, they go to their respective locations based on their filename.</li>
</ul></li>
<li>Open uberasm tool's <kbd>list.txt</kbd>, and paste these so that the codes get inserted:
<table><tr><td><pre>; Level list. Valid values: 000-1FF.
level:
104		Level_DoubleBar.asm
105		Level_Simple.asm
106		Level_RoundAwayFromComplete.asm

;[...]

gamemode:
; Insert files here
;0E		Gamemode0E_OWBorderTest.asm ;>Need OWB+ patch to function!</pre></td></tr></table><br>
</li>
<li>Insert the graphics by:
<ol>
<li>Create the &ldquo;ExGraphics&rdquo; if you haven't done so by clicking on the blue mushroom in Lunar Magic.</li>
<li>Paste the graphic bin files (from this package's &ldquo;ExGraphics&rdquo; folder) of your choice (If you want &ldquo;TransperentBackground&rdquo;
(<img width="96" src="readme_files/TransperentBackground.png">) or &ldquo;BlackBackground&rdquo; (<img width="96" src="readme_files/BlackBackground.png">))
into the other where your game resides. Then, take out the appended characters after the &ldquo;<kbd>ExGFX&lt;number&gt;</kbd>&rdquo; but before the &ldquo;<kbd>.bin</kbd>&rdquo;.<br><br>

This readme assumes you're using &ldquo;TransperentBackground&rdquo;.</li><br>
<li>Now in your level editor, click on the green poision mushroom to open a dialog about Layer 3 GFX bypass. On LG1, set that
to use the graphic files (obviously the bin files are conveniently named to tell you what slot uses what file). Level 105
and 106 LG1s to be slot 80, but for 104, it needs LG1 to be slot 81 and LG2 to be slot 82 to accommodate the large number of
tiles. Then hit OK and save to apply the changes.
</li>
</ol>
</li>
<li>Now you are done, although there are more example codes than provided here, given that you can play up to 3 levels from the get-go without beating them and without editing the overworld. If you want to test
thats not listed here, read the info in their comments at the top inside of them, the filenames should be obvious on where to insert (and don't forget to edit the list again). The examples follows:
<ul>
<li>Level 104 (Yoshi's house) is a double-bar, which can display two &ldquo;fills&rdquo; overlapping each other (<img width="96" src="readme_files/DoubleBarFills_AnotherColor.png">). Press and hold right, then
press and hold up to see. If you're using the Super Status Bar patch (and have modified the defines so that the code adopts to it), it will display 4 hex numbers at the top right, displaying the first column the amount and fill-percentage amount of FirstFill
and the other column for SecondFill.</li>
<li>Level 105 (Yoshi's island 1) is a progress meter, keep heading right to see it fills up.</li>
<li>Level 106 (Yoshi's island 2) is a coin meter, once 99 is reached, it should be full. It also avoids displaying 0% if if not 0 coins and 100% less than 99 coins,
a failsafe measure to avoid misleading value displays.</li>
<li>On the overworld border, measures Mario's Bonus Stars (does not measure Luigi's if 2-player mode).</li>
</ul>

If you're not using the Super Status Bar patch, the bar will be displayed over the word &ldquo;TIME&rdquo; and the coin symbol. The palette will be yellow on some areas,
but thats intentional as SMW's status bar is very limited.
</li>
</ol>
<hr>
<h2>Displaying your own value as a graphical bar</h2>
Perhaps if you want to display something other than the provided examples above, here are the templates:

<ul>
<li>A simple graphical bar.
<table><tr><td><pre>incsrc "../GraphicalBarDefines/GraphicalBarDefines.asm"
incsrc "../GraphicalBarDefines/StatusBarSettings.asm"
;^These are needed so the defines relating to the graphical bars work.

.InputRatio
	LDA <font color="red">$0DBF|!addr</font>						;\Quantity low byte (example: current HP). Use RAM here.
	STA !Scratchram_GraphicalBar_FillByteTbl		;/
	LDA <font color="red">#$00</font>						;\High byte of above. Should your value here is 8-bit or only 1 byte long,
	STA !Scratchram_GraphicalBar_FillByteTbl+1		;/use [LDA #$00 : STA !Scratchram_GraphicalBar_FillByteTbl+1].
	LDA <font color="red">#$63</font>						;\Max quantity low byte (example: max HP). Can be a fixed value (#$) or adjustable RAM in-game.
	STA !Scratchram_GraphicalBar_FillByteTbl+2		;/
	LDA <font color="red">#$00</font>						;\High byte of above, same format as &lt;Value_high_byte&gt;, so do the same
	STA !Scratchram_GraphicalBar_FillByteTbl+3		;/as that if your value is 8-bit.
.InputGraphicalBarAttributes
	LDA.b <font color="green">#!Default_LeftPieces</font>				;\Left end normally have 3 pieces.
	STA !Scratchram_GraphicalBar_LeftEndPiece		;/
	LDA.b <font color="green">#!Default_MiddlePieces</font>				;\Number of pieces in each middle byte/8x8 tile
	STA !Scratchram_GraphicalBar_MiddlePiece		;/
	LDA.b <font color="green">#!Default_RightPieces</font>				;\Right end
	STA !Scratchram_GraphicalBar_RightEndPiece		;/
	LDA.b <font color="green">#!Default_MiddleLength</font>				;\length (number of middle tiles)
	STA !Scratchram_GraphicalBar_TempLength			;/
.ConvertToBar
	JSL GraphicalBarELITE_CalculateGraphicalBarPercentage		;>Get percentage
	<font color="orange">JSL GraphicalBarELITE_RoundAwayEmptyFull</font>
	JSL GraphicalBarELITE_DrawGraphicalBar				;>get bar values.
	JSL GraphicalBarConvertToTile_ConvertBarFillAmountToTiles	;>Convert tiles.
	LDA.b <font color="yellow">#!Default_GraphicalBarPosition</font>				;\Setup address to where to draw the bar.
	STA $00								;|
	LDA.b <font color="yellow">#!Default_GraphicalBarPosition>>8</font>				;|
	STA $01								;|
	LDA.b <font color="yellow">#!Default_GraphicalBarPosition>>16</font>			;|
	STA $02								;/
	if !StatusBar_UsingCustomProperties != 0
		LDA.b <font color="yellow">#!Default_GraphicalBarProperties</font>				;\Same as above but properties
		STA $03								;|
		LDA.b <font color="yellow">#!Default_GraphicalBarProperties>>8</font>			;|
		STA $04								;|
		LDA.b <font color="yellow">#!Default_GraphicalBarProperties>>16</font>			;|
		STA $05								;/
		if !Default_LeftwardsBar == 0
			LDA.b <font color="green">#!Default_StatusBar_TilePropertiesSetting</font>			;\Properties
		else
			LDA.b <font color="green">#(!Default_StatusBar_TilePropertiesSetting|(!Default_LeftwardsBar<<6))</font></<6))<>
		endif
		STA $06								;/
	endif
	if !Default_LeftwardsBar == 0
		if !StatusBarFormat = $01
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUD			;>Write to status bar
		else
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDFormat2		;>Write to status bar
		endif
	else
		if !StatusBarFormat = $01
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDLeftwards
		else
			JSL GraphicalBarWriteToStatusBar_WriteBarToHUDLeftwardsFormat2
		endif
	endif
	RTL</pre></td></tr></table><br>
Font colored in <font color="red">red</font> is the things you change, while the <font color="green">green</font>, you edit values in the defines via opening up
<kbd>GraphicalBarDefines/StatusBarSettings.asm</kbd> and changing those, and yes, you can safely redefine them when you have multiple bars for advanced use. <font color="yellow">Yellow</font>
is the same as green, but it has to be a 3-byte (24-bit) address. <font color="orange">Orange</font> means you can remove the rounding away code if you want the bar to be able to round
towards empty or full. Of course, the <kbd>#</kbd> symbol means a fixed number instead of a RAM address.<br><br>

Also if you are handling 16-bit mode quantity while on 8-bit accumulator, you write the 16-bit number <kbd>#$1234</kbd> (a fixed value not stored in RAM) as
storing the <kbd>#$34</kbd> onto the low byte and <kbd>#$12</kbd> on the high byte (if it was RAM, it should be obvious, low byte written to low byte and high to high). Remember that
the SNES is little-endian when the bytes are adjacent from one another in memory.</li><br>

<li>Double Bar. See <a name="DoubleBar" href="readme_files/DoubleBarInfo.html">this information</a>. The colored fonts last mentioned above code also applies on codes here as well.</li>

</ul>
<hr>
<h2>ASM Documentation</h2>
Note: All values here are unsigned. Routine information follows:
<ol>
<li>Inside <kbd>GraphicalBarELITE.asm</kbd></li>
<ul>
<li><kbd>CalculateGraphicalBarPercentage</kbd>: Calculates the ratio of Quantity over MaxQuantity to X over the number of pieces (the whole bar).
For example: 50/100 on a 62-pieced bar outputs value of 31.</li>
<table>
<tr>
<th>RAM input</th>
<th>Description</th>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_FillByteTbl</b></span></kbd> to
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_FillByteTbl+1</b></span></kbd> (16-bit)
</td>
<td>The number or amount of something out of the maximum (known as the &ldquo;quantity&rdquo;).</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_FillByteTbl+2</b></span></kbd> to
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_FillByteTbl+3</b></span></kbd> (16-bit)
</td>
<td>The maximum amount something. If this value is <kbd>$0000</kbd>, will assume
the bar is full due to dividing by zero (known as &ldquo;max quantity&rdquo;).</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_LeftEndPiece</b></span></kbd>,
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_MiddlePiece</b></span></kbd>,
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_RightEndPiece</b></span></kbd>, and
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_TempLength</b></span></kbd> (8-bit each)
</td>
<td>Graphical bar attributes. The ones with the word &ldquo;piece&rdquo; refer to the number of pieces
or units in their respective byte or 8x8 tile. When 0, they are not included in the table. <kbd>!Scratchram_GraphicalBar_TempLength</kbd>
is the number of repeated middle tile bytes between the left and right end tile bytes.<br><br>

The reason why the pieces setup is RAM-based is so you can have different number of pieces in any bar part (left, middle, and right), for example,
<a href="readme_files/LeftEndMorePieces.png" target="_blank"> 6 pieces for left end</a> along with 3 in the same routine. However, you have to have
both tables in the tile converter in <kbd>GraphicalBarConvertToTile.asm</kbd> to avoid glitched tiles.</td>
</tr>
<tr>
</table>
Result:
<table>
<tr>
<th>Output:</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><b>$00</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$01</b></span></kbd> (16-bit)</td>
<td>The amount of fill as a &ldquo;percentage&rdquo;. Calculated by <kbd>FillAmount = RoundHalfUp(Quantity * TotalNumberOfPiecesInBar / MaxQuantity)</kbd></td>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><b>Y register</b></span></kbd></td>
<td>Rounding towards empty and full indicator:
<ul>
<li>Y = $00 if not rounded to empty or full (if exact empty, rounded to any number besides 0 or maximum, or full (or higher))</li>
<li>Y = $01 if rounded to empty.</li>
<li>Y = $02 if rounded to full.</li>
See more information <a name="RoundAwayFromComplete" href="readme_files/RoundAwayFromComplete.html">here</a>.
</ul></td>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><b>$02</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$09</b></span></kbd></td>
<td>Overwritten by math routines. Contains garbage values.</td>
</tr>
</tr>
</table>

<li><kbd>DrawGraphicalBar</kbd>: it takes a value representing how much fill in the bar, and represent them as individual tiles bytes table containing a number of them that is &ldquo;full&rdquo;,
one byte holding the &ldquo;fraction&rdquo; and then a number of &ldquo;empty&rdquo; bytes after if any of them exist. If you were to add up each byte, the total would equal to the value the number of pieces
you entered. The inputs are similar to the previously mentioned routine (such as requiring the attributes), but you don't write to <span class="NoLineBreak"><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd></span> to
<span class="NoLineBreak"><kbd>!Scratchram_GraphicalBar_FillByteTbl+3</kbd></span>, as it is no longer needed. Just to keep in mind, the attributes are kept after running this routine, so you don't have to rewrite them again.
<kbd><span class="NoLineBreak"><b>$00</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$01</b></span></kbd> is the number of units (or pieces) filled as the input. It is important to note that this output table isn't tile numbers but rather
<i>fill amounts</i>, to be indexed into tile numbers (to allow different tile graphic locations for the same routine (such as different format on the overworld compared to level)). The only different
input here is <kbd>$00</kbd>:<br><br>

<table>
<tr>
<th>Input</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><b>$00</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$01</b></span></kbd> (16-bit)</td>
<td>The amount of fill in the bar, as in, the total number of pieces filled.<br><br>

The total number of pieces (full amount) in the bar is calculated as: <kbd>[FullAmount = LeftEndPiece + (MiddlePiece * MiddleLength) + RightEndPiece]</kbd>,
for example: 62 = 3 + (7 * 8) + 3</td>
</tr>
</table>
Result:
<table>
<tr>
<th>Output</th>
<th>Description</th>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_FillByteTbl</b></span></kbd> to <kbd><span class="NoLineBreak"><b>!Scratchram_GraphicalBar_FillByteTbl+X</b></span></kbd>
</td>
<td>
The table containing a series of bytes ordered from full, then one containing a fraction byte (it ranges from <kbd>0</kbd> to <kbd>max-1</kbd>), then a series of empty bytes.
Should the bar be more than full (say, 63 out of 62 pieces), the values stored in this table will act as if the bar is full and does not write higher values nor write
additional bytes.<br><br>


The ending address is
<table><tr><td><pre>X = (LeftEnd + MiddleLength + RightEnd) - 1</pre></td></tr></table>
And the number of bytes this table uses is the same formula above but without the &ldquo;<kbd>- 1</kbd>&rdquo;.<br><br>
where:
<ul>
<li><kbd>LeftEnd</kbd> is 0 if the left end have 0 pieces and 1 if any non-zero number.</li>
<li><kbd>RightEnd</kbd> is the same as above but for right end.</li>
<li><kbd>MiddleLength</kbd> is equal to <kbd>!Scratchram_GraphicalBar_TempLength</kbd> (number of middle tiles) if
<kbd>!Scratchram_GraphicalBar_MiddlePiece</kbd> is a nonzero number, and 0 otherwise.
</ul>
If you are using &ldquo;DoubleBar&rdquo;, it is the duplicate table of above, just located
nth bytes after depending on what you set <span class="NoLineBreak"><kbd>!GraphicalBar_TotalTileUsed</kbd></span>.
See <a href="readme_files/DoubleBarInfo.html#SecondTable" target="_blank">this information</a> for what I mean.
</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><b>$00</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$07</b></span></kbd>
</td>
<td>
Garbage:
<ul>
<li><kbd><span class="NoLineBreak"><b>$00</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$01</b></span></kbd>:</li>
<ul>
<li>If the right end exist without regards of the middle and left end, will contain the right end amount.</li>
<li>#$00 if right end does not exist and middle exist.</li>
<li>If the left end only exist and middle and right are not, contains the left end amount.</li>
</ul>

<li><kbd><span class="NoLineBreak"><b>$02</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$07</b></span></kbd>: Needed to move the values to another
address due to subroutines as well as outputs of the subroutines.</li>
</ul>
</td>
</tr>
<tr>
<td>
<kbd><span class="NoLineBreak"><b>$08</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$09</b></span></kbd>
</td>
<td>
The amount of fill that was <kbd><span class="NoLineBreak"><b>$00</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$01</b></span></kbd> was originally before calling this routine, the value is not
capped, so inputting a number 63 when there are 62 pieces will have this RAM address storing the value 63. Can be used on such things like &ldquo;multi-bars&rdquo; that multiple bars are shown, and the
fills advances to the next bar: <img src="readme_files/MultiBar.gif"
</td>
</tr>
</table>
This is what it looks like as an example:
<ul>
<li><font color="cyan">Cyan</font> means the left end tile byte.</li>
<li><font color=#00C000>Green</font> means the middle tile byte(s).</li>
<li><font color="scarlet">Red</font> means right end tile byte.</li>
<li><font color="orange">Orange </font> means the tile byte is full or reaches maximum.</li>
<li><font color="yellow">Yellow</font> means the tile byte is between 0 to max-1 inclusively (known as a fraction tile).</li>
<li><font color="grey">Grey</font> means the tile byte is empty.</li><br>
</ul>
<table>
<tr>
<td>
<pre>;These three are what sets the maximum fill values for the byte table.
 <font color="cyan">!Scratchram_GraphicalBar_LeftEndPiece:      $03</font>
 <font color=#00C000>!Scratchram_GraphicalBar_MiddlePiece:       $08</font>
 <font color="scarlet">!Scratchram_GraphicalBar_RightEndPiece:     $03</font>
;This is how long the middle section.
 <font color=#00C000>!Scratchram_GraphicalBar_TempLength:        $07</font>
;The number of units or pieces filled:
 RAM address $00-$01:                        $0017 (23)</pre>
</td>
<td>


<pre>ASCII art depicting the byte table and how each byte correlates to the table.

                                     Table: <span style="background-color: orange">$03</span>,<span style="background-color: orange">$08</span>,<span style="background-color: orange">$08</span>,<span style="background-color: yellow"><font color="black">$04</font></span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>,<span style="background-color: grey">$00</span>
                                             |   |   |   |   |   |   |   |   |
<font color="cyan">!Scratchram_GraphicalBar_FillByteTbl+0</font> ------/   |   |   |   |   |   |   |   |
<font color=#00C000>!Scratchram_GraphicalBar_FillByteTbl+1</font> ----------/   |   |   |   |   |   |   |
<font color=#00C000>!Scratchram_GraphicalBar_FillByteTbl+2</font> --------------/   |   |   |   |   |   |
<font color=#00C000>!Scratchram_GraphicalBar_FillByteTbl+3</font> ------------------/   |   |   |   |   |
<font color=#00C000>!Scratchram_GraphicalBar_FillByteTbl+4</font> ----------------------/   |   |   |   |
<font color=#00C000>!Scratchram_GraphicalBar_FillByteTbl+5</font> --------------------------/   |   |   |
<font color=#00C000>!Scratchram_GraphicalBar_FillByteTbl+6</font> ------------------------------/   |   |
<font color=#00C000>!Scratchram_GraphicalBar_FillByteTbl+7</font> ----------------------------------/   |
<font color="scarlet">!Scratchram_GraphicalBar_FillByteTbl+8</font> --------------------------------------/
</pre><br>
Note: define <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> is an address, thus the above math (note the <kbd>+x</kbd>) means you add the value of the address (not the value stored in)
to get the relative location (so if <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> is being defined as <kbd>$7F844A</kbd> and you have <kbd>!Scratchram_GraphicalBar_FillByteTbl+1</kbd>,
that is <kbd>$7F844A + 1</kbd> which is address <kbd>$7F844B</kbd>).
</td>
</tr>
</table><br>

If any maximum was set to $00, they are excluded from the table and are skipped (no longer uses the ASCII lookup table for smaller display):
<table>
<tr>
<td>
<pre>
<font color="cyan"><s>!Scratchram_GraphicalBar_LeftEndPiece:       $00</s></font>
<font color=#00C000>!Scratchram_GraphicalBar_MiddlePiece:        $08</font>
<font color="scarlet">!Scratchram_GraphicalBar_RightEndPiece:      $03</font>
<font color=#00C000>!Scratchram_GraphicalBar_TempLength:         $07</font>
RAM address $00-$01:                         $0017 (23)</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address:</td>
<td bgcolor=#00C000><kbd>+0</kbd></td>
<td bgcolor=#00C000><kbd>+1</kbd></td>
<td bgcolor=#00C000><kbd>+2</kbd></td>
<td bgcolor=#00C000><kbd>+3</kbd></td>
<td bgcolor=#00C000><kbd>+4</kbd></td>
<td bgcolor=#00C000><kbd>+5</kbd></td>
<td bgcolor=#00C000><kbd>+6</kbd></td>
<td bgcolor="scarlet"><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="yellow"><font color="black"><kbd>$07</kbd></font></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<pre>
<font color="cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $03</font>
<font color=#00C000><s>!Scratchram_GraphicalBar_MiddlePiece:        $00</s></font>
<font color="scarlet">!Scratchram_GraphicalBar_RightEndPiece:      $03</font>
<font color=#00C000><s>!Scratchram_GraphicalBar_TempLength:         $00</s></font>
RAM address $00-$01:                         $0004 (4)

Note: !Scratchram_GraphicalBar_MiddlePiece <u>and/or</u>
!Scratchram_GraphicalBar_TempLength is set to zero,
excludes the middle section.</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address:</td>
<td bgcolor="cyan"><font color="black"><kbd>+0</kbd></font></td>
<td bgcolor="scarlet"><kbd>+1</kbd></td>
<td><kbd>+2</kbd></td>
<td><kbd>+3</kbd></td>
<td><kbd>+4</kbd></td>
<td><kbd>+5</kbd></td>
<td><kbd>+6</kbd></td>
<td><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td bgcolor="orange"><kbd>$03</kbd></td>
<td bgcolor="yellow"><font color="black"><kbd>$01</kbd></font></td>
<td colspan="7"><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
<tr>
<td>
<pre><font color="cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $03</font>
<font color=#00C000>!Scratchram_GraphicalBar_MiddlePiece:        $08</font>
<font color="scarlet"><s>!Scratchram_GraphicalBar_RightEndPiece:      $00</s></font>
<font color=#00C000>!Scratchram_GraphicalBar_TempLength:         $07</font>
RAM address $00-$01:                         $0017 (23)</pre>
</td>
<td>

<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address:</td>
<td bgcolor="cyan"><font color="black"><kbd>+0</kbd></font></td>
<td bgcolor=#00C000><kbd>+1</kbd></td>
<td bgcolor=#00C000><kbd>+2</kbd></td>
<td bgcolor=#00C000><kbd>+3</kbd></td>
<td bgcolor=#00C000><kbd>+4</kbd></td>
<td bgcolor=#00C000><kbd>+5</kbd></td>
<td bgcolor=#00C000><kbd>+6</kbd></td>
<td bgcolor=#00C000><kbd>+7</kbd></td>
<td><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values:</td>
<td bgcolor="orange"><kbd>$03</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="yellow"><font color="black"><kbd>$04</kbd></font></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td><kbd>(unused, garbage)</kbd></td>
</tr>
</table>
</td>
</tr>
</tr>
</table><br>
Of course, I made a <a name="ComputeGraphicalBarData" href="readme_files/JS_GraphicalBarCalculator.html">javascript code page</a> that calculates memory statistics
without the need of manually calculating the values.<br><br>
</li>

<li><kbd>RoundAwayEmpty</kbd>, <kbd>RoundAwayFull</kbd>, and <kbd>RoundAwayEmptyFull</kbd>: After getting the Y register value from <kbd>CalculateGraphicalBarPercentage</kbd>, this increments or
decrements the fill amount <kbd>$00-$01</kbd> by 1 so it will display 1 and/or <kbd>MaxFill-1</kbd> instead of showing 0 and/or <kbd>MaxFill</kbd> when the value is rounded towards them. The names
of the routine should be obvious (e.g. <kbd>RoundAwayEmpty</kbd> means round away from empty).</li><br>
</ul>
<li>Inside <kbd>GraphicalBarConvertToTile.asm</kbd></li>
<ul>
<li><kbd>ConvertBarFillAmountToTiles</kbd>: converts the bar fill table into tile numbers via indexing (inputs the same as above and don't
need to be rewritten):

<table>
<tr>
<th>Left end</th>
<th>Middle</th>
<th>Right end</th>
</tr>
<tr>
<td><ul>
<li><kbd>Fill amount $00 &rightarrow; tile number $36</kbd> <img src="readme_files/GraphicalBarFills/LeftEnd_0_of_3.png"></li>
<li><kbd>Fill amount $01 &rightarrow; tile number $37</kbd> <img src="readme_files/GraphicalBarFills/LeftEnd_1_of_3.png"></li>
<li><kbd>Fill amount $02 &rightarrow; tile number $38</kbd> <img src="readme_files/GraphicalBarFills/LeftEnd_2_of_3.png"></li>
<li><kbd>Fill amount $03 &rightarrow; tile number $39</kbd> <img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"></li>
</ul></td>
<td><ul>
<li><kbd>Fill amount $00 &rightarrow; tile number $55</kbd> <img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></li>
<li><kbd>Fill amount $01 &rightarrow; tile number $56</kbd> <img src="readme_files/GraphicalBarFills/Middle_1_of_8.png"></li>
<li><kbd>Fill amount $02 &rightarrow; tile number $57</kbd> <img src="readme_files/GraphicalBarFills/Middle_2_of_8.png"></li>
<li><kbd>Fill amount $03 &rightarrow; tile number $58</kbd> <img src="readme_files/GraphicalBarFills/Middle_3_of_8.png"></li>
<li><kbd>Fill amount $04 &rightarrow; tile number $59</kbd> <img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"></li>
<li><kbd>Fill amount $05 &rightarrow; tile number $65</kbd> <img src="readme_files/GraphicalBarFills/Middle_5_of_8.png"></li>
<li><kbd>Fill amount $06 &rightarrow; tile number $66</kbd> <img src="readme_files/GraphicalBarFills/Middle_6_of_8.png"></li>
<li><kbd>Fill amount $07 &rightarrow; tile number $67</kbd> <img src="readme_files/GraphicalBarFills/Middle_7_of_8.png"></li>
<li><kbd>Fill amount $08 &rightarrow; tile number $68</kbd> <img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></li>
</ul></td>
<td><ul>
<li><kbd>Fill amount $00 &rightarrow; tile number $50</kbd> <img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png"></li>
<li><kbd>Fill amount $01 &rightarrow; tile number $51</kbd> <img src="readme_files/GraphicalBarFills/RightEnd_1_of_3.png"></li>
<li><kbd>Fill amount $02 &rightarrow; tile number $52</kbd> <img src="readme_files/GraphicalBarFills/RightEnd_2_of_3.png"></li>
<li><kbd>Fill amount $03 &rightarrow; tile number $53</kbd> <img src="readme_files/GraphicalBarFills/RightEnd_3_of_3.png"></li>
</ul></td>
</tr>
</table><br>

So if <kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd> contains these values and gets converted, this happens:
<table>
<tr>
<td><kbd>!Scratchram_GraphicalBar_FillByteTbl</kbd><br>
relative address:</td>
<td bgcolor="cyan"><font color="black"><kbd>+0</kbd></font></td>
<td bgcolor=#00C000><kbd>+1</kbd></td>
<td bgcolor=#00C000><kbd>+2</kbd></td>
<td bgcolor=#00C000><kbd>+3</kbd></td>
<td bgcolor=#00C000><kbd>+4</kbd></td>
<td bgcolor=#00C000><kbd>+5</kbd></td>
<td bgcolor=#00C000><kbd>+6</kbd></td>
<td bgcolor=#00C000><kbd>+7</kbd></td>
<td bgcolor="scarlet"><kbd>+8</kbd></td>
</tr>
<tr>
<td>Table values...:</td>
<td bgcolor="orange"><kbd>$03</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="yellow"><font color="black"><kbd>$04</kbd></font></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
<td bgcolor="grey"><kbd>$00</kbd></td>
</tr>
<tr>
<td>...converted to tile number:</td>
<td bgcolor="orange"><kbd>$39</kbd></td>
<td bgcolor="orange"><kbd>$68</kbd></td>
<td bgcolor="orange"><kbd>$68</kbd></td>
<td bgcolor="yellow"><font color="black"><kbd>$59</kbd></font></td>
<td bgcolor="grey"><kbd>$55</kbd></td>
<td bgcolor="grey"><kbd>$55</kbd></td>
<td bgcolor="grey"><kbd>$55</kbd></td>
<td bgcolor="grey"><kbd>$55</kbd></td>
<td bgcolor="grey"><kbd>$50</kbd></td>
</tr>
<tr>
<td>Tile image:</td>
<td><center><img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"></center></td>
<td><center><img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png"></center></td>
</tr>
<tr>
<td>
Result:
</td>
<td colspan="9">
<center>
<span class="NoLineBreak">
<img src="readme_files/GraphicalBarFills/LeftEnd_3_of_3.png"><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_8_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_4_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/Middle_0_of_8.png"><img src="readme_files/GraphicalBarFills/RightEnd_0_of_3.png">
</span>
</center>
</td>
</tr>
</table><br>
If you changed the number of pieces in any of the 3 parts of the bar (left, middle, and right), the number of pieces must equal to the number of values +1 (+1 because an empty tile byte is included)
in the table corresponding to the bar part, for example, by making left end have 4 pieces instead of 3, you must have 5 values in the left end tile table. Else your tiles will glitch.<br><br>

Note that scratch RAM <kbd>$00</kbd> and <kbd>$01</kbd> is overwritten to determine should it use overworld border version and handle a loop that translates the middle tiles.<br><br>

</li>
<li><kbd>ConvertBarFillAmountToTilesDoubleBar</kbd>: Same as above, but handles a double-filled bar. Tiles are formated <a href="readme_files/DoubleBarFills.png" target="_blank">like this</a>.
Also like above, make sure you have the number of pieces equal to <kbd>(NumberOfPieces+1)^2</kbd> number of values in table (for example, left end have 4 pieces, therefore you must have 25 values;
<kbd>(4+1)^2 = 25</kbd>). I recommend to have the table to form a perfect square so that the fill values are visually organized.</li><br>

Of course, the default graphics included here are pixel-column-based, meaning each column of pixels is 1 piece of a bar.<br><br>

Note that this does not support overworld graphics unlike above, as there are even more tiles used than the status bar.<br><br>

</ul><br>


<li>Inside <kbd>GraphicalBarWriteToStatusBar.asm</kbd>. Note that there are two similar subroutines main labels with one that have &ldquo;<kbd>Format2</kbd>&rdquo; (such as <kbd>WriteBarToHUD</kbd> and
<kbd>WriteBarToHUDFormat2</kbd>) appended are the same as the other but handles a different status bar/OWB format.</li>
<ul>
<li><kbd>WriteBarToHUD</kbd>: Copies the tile numbers in the table to paste to (writes) the status bar (if you're using the Super Status Bar patch, the if statement and defines will adopt to that).
Inputs are again, similar to <kbd>CalculateGraphicalBarPercentage</kbd> with only the attributes being used, but a new input is required:

<table>
<tr>
<th>Input</th>
<th>Description</th>
</tr>
<tr>
<td><kbd><span class="NoLineBreak"><b>$00</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$02</b></span></kbd> (24-bit)</td>
<td>The starting address (left end, extends rightwards, even when the bar is set to fill leftwards) location to write the tile numbers to the status bar.</td>
</tr>
<td><kbd><span class="NoLineBreak"><b>$03</b></span></kbd> to <kbd><span class="NoLineBreak"><b>$05</b></span></kbd> (24-bit)</td>
<td>The starting address (left end, extends rightwards, even when the bar is set to fill leftwards) location to write the tile properties to the status bar.
(This only works if you installed status bar patches that enable editing the properties in-game, and set <kbd>!StatusBar_UsingCustomProperties</kbd> to <kbd>1</kbd>,
else this is no longer needed to write values to this input). I deliberately used the if statement around this to prevent writing to an arbitrary address (the <span class="NoLineBreak"><kbd>STA [$03],y</kbd></span> could write to an invalid address).</td>
<tr>
<td><kbd><span class="NoLineBreak"><b>$06</b></span></kbd> (8-bit)</td>
<td>The tile properties (YXPCCCTT). Same as above, if you have it disabled, this is not used.</td>
</tr>
</table><br>
Remember that this is little endian (The address $7E0F09, for example are stored in each bytes as
<pre>$7E0000: $09
$7E0001: $0F
$7E0002: $7E</pre>

so be careful on that.).
Of course, because the <a href="https://www.smwcentral.net/?p=section&a=details&id=15222">Overworld Border Plus</a> patch have the same format as the Super Status Bar patch,
it will work on that as well (if <kbd>!StatusBarFormat</kbd> set to $02 and you make a different version of the routine <kbd>ConvertBarFillAmountToTiles</kbd> to use a different
table to use OW layer 3 tiles).<br><br>

<li><kbd>WriteBarToHUDLeftwards</kbd>: Same as above, but only works properly if you managed to set bit 6 of YXPCCCTT properties byte. This will write a X-flipped version that
the bar now fills from right to left. Tiles arranged are flipped so the leftmost tile (including the end tiles) is now the right most, the second leftmost is second rightmost,
and so on. If you didn't X-flip the tiles via editing the tile properties (YXPCCCTT), each tile won't be X-flipped but are still arranged backwards (when filling up, the rightmost
tile fills towards the right and advances to the tile towards the left). In vanilla SMW, it is still possible to edit the tile properties (but cannot be changed in-game as the
data is stored in ROM) at around address <kbd>$008C81</kbd>.</li><br>

<li><kbd>BarExtendLeft</kbd>: Normally, without this routine, as the bar's length (not to be confused with the above routine) increases (say, increase the middle length), the
bar always extends rightwards. With this, you call this routine before you call <kbd>WriteBarToHUD</kbd> or <kbd>WriteBarToHUDLeftwards</kbd> to make it extend leftwards. What
happens is that it calculates where the leftmost tile would be at depending on the length of the bar, so the &ldquo;origin tile &rdquo; of the position gets moved.
This is useful for displaying enemy HP bars that are &ldquo;right aligned&rdquo; that have lengths proportional to how much max HP the enemy has and extend leftwards.<br><br>

Be careful with bank borders crossing (don't have status bar tile tables that goes from <kbd>$7EFFFF</kbd> to <kbd>$7F0000</kbd>, for a made-up example), as I discovered that
Akaginite's <kbd>16Bit - 8Bit</kbd> (done by <kbd>((-8Bit) + 16Bit</kbd>)) does not work with bank borders if <kbd>8Bit</kbd> is <kbd>$00</kbd> because that causes the carry flag
to be clear, unlike the normal SBC. However, this is very unlikely as no status bar tile tables would ever do that.</li>
</li>
</ul>
</ol>

<hr>
<h2>Notes</h2>
<ul>

<li>Due to how this routine works, when display a fill edge that encompass multiple 8x8 bytes at once, it doesn't work, as it was designed to have a single fraction tile.<br>
<center><img src="readme_files/MultiPartiallyFilled.png"></center><br>
You have to check the tile byte adjacent to the fraction byte to determine to show the &ldquo;second half&rdquo; of the fill edge. The logic on this is very complex and therefore
a tutorial for that is not included.</li>
<li>You don't have to call the routine <kbd>CalculateGraphicalBarPercentage</kbd> to use <kbd>DrawGraphicalBar</kbd>, this means you can make an icon-based HP system that each
tile byte holds a set amount of HP, for example, in the <i>Legend of Zelda</i> series starting in <i>Ocarina of Time</i>, you can have each heart containing 4 pieces representing each 1 HP.</li>
<li>It is best to avoid having any end tiles holding the same number of pieces as the middle, although it still works, it is less optimized as the routine <kbd>DrawGraphicalBar</kbd>
only takes a value and represent them as each bytes capped at their maximum. Therefore if you're planning to have 8 pieces for both left and right ends, and have 7 middle bytes also
having 8 pieces at the max, it is better to have both end tiles set to 0 pieces and have 9 middle tiles holding 8 pieces, here is what it looks like on a full bar:<br><br>

Less optimized:
<table><tr><td><pre><font color="cyan">!Scratchram_GraphicalBar_LeftEndPiece:       $08</font>
<font color=#00C000>!Scratchram_GraphicalBar_MiddlePiece:        $08</font>
<font color="scarlet">!Scratchram_GraphicalBar_RightEndPiece:      $08</font>
<font color=#00C000>!Scratchram_GraphicalBar_TempLength:         $07</font>
RAM address $00-$01:                         $0048 (72)</pre></td></tr></table>
Result:
<table>
<tr>
<td bgcolor="cyan"><font color="black"><kbd>+0</kbd></font></td>
<td bgcolor=#00C000><kbd>+1</kbd></td>
<td bgcolor=#00C000><kbd>+2</kbd></td>
<td bgcolor=#00C000><kbd>+3</kbd></td>
<td bgcolor=#00C000><kbd>+4</kbd></td>
<td bgcolor=#00C000><kbd>+5</kbd></td>
<td bgcolor=#00C000><kbd>+6</kbd></td>
<td bgcolor=#00C000><kbd>+7</kbd></td>
<td bgcolor="scarlet"><kbd>+8</kbd></td>
</tr>
<tr>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
</tr>
</table>
Vs optimized:
<table><tr><td><pre><font color="cyan"><s>!Scratchram_GraphicalBar_LeftEndPiece:       $00</s></font>
<font color=#00C000>!Scratchram_GraphicalBar_MiddlePiece:        $08</font>
<font color="scarlet"><s>!Scratchram_GraphicalBar_RightEndPiece:      $00</s></font>
<font color=#00C000>!Scratchram_GraphicalBar_TempLength:         $09</font>
RAM address $00-$01:                         $0048 (72)</pre></td></tr></table>
Result:
<table>
<tr>
<td bgcolor=#00C000><kbd>+0</kbd></td>
<td bgcolor=#00C000><kbd>+1</kbd></td>
<td bgcolor=#00C000><kbd>+2</kbd></td>
<td bgcolor=#00C000><kbd>+3</kbd></td>
<td bgcolor=#00C000><kbd>+4</kbd></td>
<td bgcolor=#00C000><kbd>+5</kbd></td>
<td bgcolor=#00C000><kbd>+6</kbd></td>
<td bgcolor=#00C000><kbd>+7</kbd></td>
<td bgcolor=#00C000><kbd>+8</kbd></td>
</tr>
<tr>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
<td bgcolor="orange"><kbd>$08</kbd></td>
</tr>
</table>
The only difference is the FillAmount &rightarrow; TileNumber conversion <kbd>ConvertBarFillAmountToTiles</kbd> (and the doublebar version) that utilizes the tile number you need
to change (Left end have 9 tiles with values 0-8 same as middle's 0-8 but uses a different array tiles to display a outlined-left edge and same goes to the right end). However,
the tile converter does not recognize if the first and last tile are meant to be end tiles to have different graphic than the middle, so just before calling the tile converter,
set the end tiles to be the same number of pieces for middle, and subtract the number of middle tiles by how many end tiles you are using (say 2) so that the end tiles don't use
the same table graphic as middle and cause cutoff-ended bar.
<table><tr><td><pre>	;[...]
	JSL GraphicalBarELITE_DrawGraphicalBar				;>get bar values.
	LDA #$08							;\Middle tiles first and last replaced with end tiles.
	STA !Scratchram_GraphicalBar_LeftEndPiece			;|
	STA !Scratchram_GraphicalBar_RightEndPiece			;|
	LDA !Scratchram_GraphicalBar_TempLength				;|
	SEC								;|
	SBC #$02							;|>Left end + Right end = 2 end tiles
	STA !Scratchram_GraphicalBar_TempLength				;/
	JSL GraphicalBarConvertToTile_ConvertBarFillAmountToTiles	;>Convert tiles (end tiles recognized).
	;[...]</pre></td></tr></table><br><br>

</li>
<li>You might've noticed the define <span class="NoLineBreak"><kbd>!Settings_GraphicalBar_IndexSize</kbd></span> found in <kbd>GraphicalBarDefines.asm</kbd>, I left that there in for some rare cases anyone
would need a bar that is more than 255 tile bytes long (So a 16-bit addressing was needed).</li>
<li>Be careful when you call the routine <kbd>WriteBarToHUD</kbd> (and <kbd>WriteBarToHUDLeftwards</kbd>), as because this is multi-bytes based, it will write from
<span class="NoLineBreak"><kbd>!Default_GraphicalBarPosition</kbd></span> to <span class="NoLineBreak"><kbd>!Default_GraphicalBarPosition+((NumberOfTiles-1)*!StatusBarFormat)</kbd></span> address. Thus if you place the bar at RAM address
<kbd>$0F2F</kbd>, the address bytes beyond that (which is non-status-bar-related data, from timer data, scores, then an unused RAM area ($0F3A) and so on) gets overwritten.</li>
<ul><li>However, if you are using the &ldquo;extend leftwards&rdquo; (not to be confused with a leftwards <b>filling bar</b>; the bar that extends leftwards as you increase the length),
the address write range is <kbd>DesiredLastTilePos-((NumberOfTiles-1)*!StatusBarFormat)</kbd> to <kbd>DesiredLastTilePos</kbd>, so be careful not to have the bar data be written past the starting RAM
address of the status bar (avoid placing the <kbd>DesiredLastTilePos</kbd> that would cause placing the tiles before the first byte of the status bar tiles).</li></ul>
</ul>
<hr>
<h2>Credits</h2>
<ul>
<li><a href="https://www.smwcentral.net/?p=profile&id=8691">Akaginite</a>, for making the math routines</li>
<li><a href="https://www.w3schools.com/">W3Schools</a> and <a href="https://stackoverflow.com">stackoverflow</a><sup><a href="https://stackoverflow.com/questions/11409895/whats-the-most-elegant-way-to-cap-a-number-to-a-segment">[1]</a></sup>, for making a tutorial on how to make HTML and javascript codes.</li>
</ul>